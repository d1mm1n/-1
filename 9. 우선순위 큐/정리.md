# 우선순위 큐 정리

## 9.1 우선순위 큐 추상 데이터 타입
  ### 우선순위 큐의 소개

우선순위 큐는 큐에 우선 순위의 개념을 도입한 것

큐와 다르게 우선순위 큐는 우선 순위가 높은 데이터가 먼저 나가게 된다.

***


### 우선순위 큐 추상 자료형

- 객체: n개의 element형의 우선 순위를 가진 요소들의 모임

- 연산:
   
    create() ::= 우선순위 큐를 생성한다.

    init(q) ::= 우선순위 큐 q를 초기화 한다.

    is_empty(q) ::= 우선순위 큐 q가 비어있는지를 검사한다.

    is_full(q) ::= 우선순위 큐 q가 가득 찼는가를 검사한다.

    insert(q, x) ::= 우선순위 큐 q에 요소 x를 추가한다.

    delete(q) ::= 우선순위 큐로부터 가장 우선순위가 높은 요소를 삭제하고 이 요소를 반환 한다.

    find(q) ::= 우선순위가 가장 높은 요소를 반환한다.

## 9.2 우선순위 큐의 구현 방법
### 배열을 사용하는 방법
배열을 사용하는 경우 그냥 배열의 맨끝에 새로운 요소를 추가하면 된다.
삽입 시간 복잡도는 O(1) 
정렬이 안되어 있으므로 처음부터 끝까지 모든 요소들을 스캔해야함
따라서 삭제의 복잡도는 O(n) 이 된다.



정렬이 되어있지 않은 경우에는 새로운 요소를 삽입할 때에는 다른 요소와 값을 비교하여 적절한 삽입 위치를 결정해야 한다. 삽입 위치를 찾기 위해 순차탐색, 이진탐색과 같은 방법 이용 가능
삽입 위치 뒤에 있는 요소들을 이동시켜 빈자리도 만들어주어야 하기 때문에 삽입의 시간 복잡도는 O(n) 이다. 
삭제의 경우에는 예를 들어 숫자가 높은 것이 우선순위가 높다고 가정하였을 경우 맨뒤에 위치한 요소를 삭제하면 됨으로 시간 복잡도는 O(1) 이다.

----------------------------

### 연결 리스트를 사용하는 방법

정렬이 안된 연결 리스트라묜 삽입 시에는 첫번째 노드로 삽입시키는 것이 유리
노드 이동은 필요 없음 포인터만 변경해주면 된다.
따라서 삽입의 시간 복잡도는 O(1)
삭제시에는 포인터를 따른 모든 노드를 뒤져보아야 한다. 이 경우 시간 복잡도는 O(n)


정렬이 되어있다면?
이경우에는 우선 순위가 높은 요소가 앞에 위치하는 것이 유리하다.
따라서 우선순위가 높은 요소가 첫 번째 노드가 되도록 한다.
삽입시에는 우선 순위값을 기준으로 삽입위치를 찾아야 하므로 O(n)
삭제 시에는 첫번 째 노드를 삭제하면 되므로 O(1)이다.

---------------------------------

### 히프를 사용하는 방법

히프(heap)는 완전 이진 트리의 일종으로 우선순위 큐를 위하여 특별히 만들어진 자료 구조이다.
히프는 느슨한 정렬 상태유지, 즉 완전히 정렬된 것은 아니지만 전혀 정렬이 안된 것도 아닌 상태를 유지한다 (이게 뭔소리;;?)

어쨋든 히프의 효율은 O(log n) 이란다.. 그래서 다른 방법보다 상당히 유리


***

여튼 시간 복잡도를 정리 해보면 아래 표와 같다.

|표현방법|삽입|삭제|
|:---|:---|:---|
|순서 없는 배열|O(1)|O(n)|
|순서 없는 연결 리스트|O(1)|O(n)|
|정렬된 배열|O(n)|O(1)|
|정렬된 연결 리스트|O(n)|O(1)|
|히프|O(log n)|O(log n)|


## 9.3 히프
### 히프의 개념

히프는 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료구조이다. 히프는 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰 이진트리를 말한다.
히프는 아래와 같은 조건이 항상 성립하는 트리
Key(부모노드)>= Key(자식노드)

히프는 완전 이진트리이기 때문에 완전이진트리가 아니면 히프가 아니다!!!!!  <br>(교재 P327 [그림 9-6] 참고)

<br>

### 히프의 종류

히프에는 두 가지 종류의 히프트리가 존재
1. 최대 히프 : Key(부모 노드) >= Key(자식 노드)
2. 최소 히프 : Key(부모 노드) <= Key(자식 노드)
   
책에서는 편의상 최대 히프만 다룬다고 함

<br>

### 히프의 구현
히프는 완전 이진트리이기 때문에 각각의 노드에 번호 붙일 수 있다.
따라서 배열에 저장 가능, 구현을 쉽게 하기 위해 배열의 첫번 째 인덱스인 0은 사용 안함
새로운 노드가 추가 되어도 노드 번호는 변하지 않음 

ex) 루트 노드의 오른쪽 노드의 번호는 항상 3번이다.

배열을 이용하여 히프를 저장하면 완전 이진트리에서처럼 자식 노드와 부모 노드를 쉽게 알 수 있다.

- 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
- 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 +1

- 부모 인덱스 = (자식의 인덱스) / 2
  
## 9.4 히프의 구현
### 히프의 정의

```c
#define MAX_ELEMENT 200
typedef struct{
    int key;
}element;

typedef struct{
    element heap[MAX_ELEMENT];
    int heap_size; //현재 히프안에 저장된 요소의 개수
}HeapType;
```

위의 정의를 이용하여 히프 heap생성
```c
Heaptype heap;
```

동적 생성
```c
HeapType *heap = create(); //메모리 동적 할당을 이용
```
<br>

### 삽입 연산

히프에 새로운 요소가 들어오면, 일단 새로운 노드를 히프의 마지막 노드로 삽입된다.
마지막 노드 다음에 새로운 노드를 위치 시키면 히프트리의 성질이 만족되지 않을 수도 있다.
따라서 삽입 후에 새로운 노드를 부모노드들과 교환해 히프의 성질을 만족시켜 주어야한다. (교재 P.331 예시 그림 참고)

<br>

#### 히프트리에서의 삽입 함수

```c
//현재 요소의 개수가 heap_size인 히프 h에 item을 삽입한다.
//삽입 함수
void insert_max_heap(HeapType *h, element item){
    int i;
    i = ++(h->heap_size);

    // 트리를 거슬러 올라가면서 부모 노드와 비교하는 과정
    while((i!=1) && item.key> h->heap[i/2].key){
        h->heap[i]= h->heap[i/2];
        i/=2;
    }
    h->heap[i]=item; //새로운 노드를 삽입
}
```
<br>

### 히프의 삭제 연산

최대 히프에서 삭제연산은 최대값을 가진 요소를 삭제하는 것.

최대 히프에서 최대값은 루트 노드이므로 루트 노드가 삭제 된다.

(교재 p.335 예시 그림 참고)

(1) 먼저 루트노드가 삭제, 빈 루트 노드 자리에는 히프의 마지막 노드를 가져온다 <nl>
(2) 새로운 루트 노드와 자식노드를 비교하여 자식노드가 더 크다면 교환이 일어난다. <nl>
(3) 더이상 교환이 필요없을 때 까지 교환을 계속 진행한다.

<br>

#### 히프트리에서의 삭제 함수

```c
//삭제 함수
element delete_max_heap(HeapType *h){
    int parent, child;
    element item, temp;

    item = h->heap[1];  //루트 노드
    temp = h->heap[(h->heap_size)--]; // 마지막 노드

    parent = 1;
    child = 2;

    while(child <= h->heap_size){
        // 현재 노드의 자식노드 중 더 큰 자식노드를 찾는다.
        if((child< h->heap_size) && (h->heap[child].key) < h->heap[child+1].key ) child++;
        if (temp.key>= h->heap[child.key]) break; //더이상 교환이 필요 없을 때
        
        //한단계 아래로 이동
        h->heap[parent]=h->heap[child];
        parent = child;
        child *= 2; //가장 왼쪽 노드로 이동
    }
    h->heap[parent] = temp;
    return item;
}
```

전체 프로그램은 깃허브에 코드로 있움~!


